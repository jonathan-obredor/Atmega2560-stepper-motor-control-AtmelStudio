
envia_recibe_serial.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800200  00000270  00000304  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000270  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000103  00800214  00800214  00000318  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000318  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000348  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000050  00000000  00000000  00000388  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000307  00000000  00000000  000003d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000019a  00000000  00000000  000006df  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000029a  00000000  00000000  00000879  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d0  00000000  00000000  00000b14  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000250  00000000  00000000  00000be4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001c1  00000000  00000000  00000e34  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  00000ff5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	8e c0       	rjmp	.+284    	; 0x122 <__bad_interrupt>
   6:	00 00       	nop
   8:	8c c0       	rjmp	.+280    	; 0x122 <__bad_interrupt>
   a:	00 00       	nop
   c:	8a c0       	rjmp	.+276    	; 0x122 <__bad_interrupt>
   e:	00 00       	nop
  10:	88 c0       	rjmp	.+272    	; 0x122 <__bad_interrupt>
  12:	00 00       	nop
  14:	86 c0       	rjmp	.+268    	; 0x122 <__bad_interrupt>
  16:	00 00       	nop
  18:	84 c0       	rjmp	.+264    	; 0x122 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	82 c0       	rjmp	.+260    	; 0x122 <__bad_interrupt>
  1e:	00 00       	nop
  20:	80 c0       	rjmp	.+256    	; 0x122 <__bad_interrupt>
  22:	00 00       	nop
  24:	7e c0       	rjmp	.+252    	; 0x122 <__bad_interrupt>
  26:	00 00       	nop
  28:	7c c0       	rjmp	.+248    	; 0x122 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	7a c0       	rjmp	.+244    	; 0x122 <__bad_interrupt>
  2e:	00 00       	nop
  30:	78 c0       	rjmp	.+240    	; 0x122 <__bad_interrupt>
  32:	00 00       	nop
  34:	76 c0       	rjmp	.+236    	; 0x122 <__bad_interrupt>
  36:	00 00       	nop
  38:	74 c0       	rjmp	.+232    	; 0x122 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	72 c0       	rjmp	.+228    	; 0x122 <__bad_interrupt>
  3e:	00 00       	nop
  40:	70 c0       	rjmp	.+224    	; 0x122 <__bad_interrupt>
  42:	00 00       	nop
  44:	6e c0       	rjmp	.+220    	; 0x122 <__bad_interrupt>
  46:	00 00       	nop
  48:	6c c0       	rjmp	.+216    	; 0x122 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	6a c0       	rjmp	.+212    	; 0x122 <__bad_interrupt>
  4e:	00 00       	nop
  50:	68 c0       	rjmp	.+208    	; 0x122 <__bad_interrupt>
  52:	00 00       	nop
  54:	66 c0       	rjmp	.+204    	; 0x122 <__bad_interrupt>
  56:	00 00       	nop
  58:	64 c0       	rjmp	.+200    	; 0x122 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	62 c0       	rjmp	.+196    	; 0x122 <__bad_interrupt>
  5e:	00 00       	nop
  60:	60 c0       	rjmp	.+192    	; 0x122 <__bad_interrupt>
  62:	00 00       	nop
  64:	5e c0       	rjmp	.+188    	; 0x122 <__bad_interrupt>
  66:	00 00       	nop
  68:	5c c0       	rjmp	.+184    	; 0x122 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	5a c0       	rjmp	.+180    	; 0x122 <__bad_interrupt>
  6e:	00 00       	nop
  70:	58 c0       	rjmp	.+176    	; 0x122 <__bad_interrupt>
  72:	00 00       	nop
  74:	56 c0       	rjmp	.+172    	; 0x122 <__bad_interrupt>
  76:	00 00       	nop
  78:	54 c0       	rjmp	.+168    	; 0x122 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	52 c0       	rjmp	.+164    	; 0x122 <__bad_interrupt>
  7e:	00 00       	nop
  80:	50 c0       	rjmp	.+160    	; 0x122 <__bad_interrupt>
  82:	00 00       	nop
  84:	4e c0       	rjmp	.+156    	; 0x122 <__bad_interrupt>
  86:	00 00       	nop
  88:	4c c0       	rjmp	.+152    	; 0x122 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	4a c0       	rjmp	.+148    	; 0x122 <__bad_interrupt>
  8e:	00 00       	nop
  90:	48 c0       	rjmp	.+144    	; 0x122 <__bad_interrupt>
  92:	00 00       	nop
  94:	46 c0       	rjmp	.+140    	; 0x122 <__bad_interrupt>
  96:	00 00       	nop
  98:	44 c0       	rjmp	.+136    	; 0x122 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	42 c0       	rjmp	.+132    	; 0x122 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	40 c0       	rjmp	.+128    	; 0x122 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3e c0       	rjmp	.+124    	; 0x122 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3c c0       	rjmp	.+120    	; 0x122 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	3a c0       	rjmp	.+116    	; 0x122 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	38 c0       	rjmp	.+112    	; 0x122 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	36 c0       	rjmp	.+108    	; 0x122 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	34 c0       	rjmp	.+104    	; 0x122 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	32 c0       	rjmp	.+100    	; 0x122 <__bad_interrupt>
  be:	00 00       	nop
  c0:	30 c0       	rjmp	.+96     	; 0x122 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2e c0       	rjmp	.+92     	; 0x122 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2c c0       	rjmp	.+88     	; 0x122 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	2a c0       	rjmp	.+84     	; 0x122 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	28 c0       	rjmp	.+80     	; 0x122 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	26 c0       	rjmp	.+76     	; 0x122 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	25 c0       	rjmp	.+74     	; 0x124 <__vector_54>
  da:	00 00       	nop
  dc:	22 c0       	rjmp	.+68     	; 0x122 <__bad_interrupt>
  de:	00 00       	nop
  e0:	9c c0       	rjmp	.+312    	; 0x21a <__vector_56>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e0 e7       	ldi	r30, 0x70	; 112
  fc:	f2 e0       	ldi	r31, 0x02	; 2
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a4 31       	cpi	r26, 0x14	; 20
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	23 e0       	ldi	r18, 0x03	; 3
 110:	a4 e1       	ldi	r26, 0x14	; 20
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a7 31       	cpi	r26, 0x17	; 23
 11a:	b2 07       	cpc	r27, r18
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	58 d0       	rcall	.+176    	; 0x1d0 <main>
 120:	a5 c0       	rjmp	.+330    	; 0x26c <_exit>

00000122 <__bad_interrupt>:
 122:	6e cf       	rjmp	.-292    	; 0x0 <__vectors>

00000124 <__vector_54>:
	
	return ret;
}

ISR(USART3_RX_vect) 
{
 124:	1f 92       	push	r1
 126:	0f 92       	push	r0
 128:	0f b6       	in	r0, 0x3f	; 63
 12a:	0f 92       	push	r0
 12c:	11 24       	eor	r1, r1
 12e:	0b b6       	in	r0, 0x3b	; 59
 130:	0f 92       	push	r0
 132:	8f 93       	push	r24
 134:	9f 93       	push	r25
 136:	ef 93       	push	r30
 138:	ff 93       	push	r31
	rxBuffer[rxWritePos] = UDR3; //"USART Data Register" UDRn es un registro de 16 bit, en este registro se guardan los datos que se van a enviar o que se han recibido
 13a:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <rxWritePos>
 13e:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
 142:	e8 2f       	mov	r30, r24
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	e9 5e       	subi	r30, 0xE9	; 233
 148:	fd 4f       	sbci	r31, 0xFD	; 253
 14a:	90 83       	st	Z, r25
	
	
	rxWritePos++;
 14c:	8f 5f       	subi	r24, 0xFF	; 255
	
	if(rxWritePos >= RX_BUFFER_SIZE)
 14e:	1a f0       	brmi	.+6      	; 0x156 <__vector_54+0x32>
ISR(USART3_RX_vect) 
{
	rxBuffer[rxWritePos] = UDR3; //"USART Data Register" UDRn es un registro de 16 bit, en este registro se guardan los datos que se van a enviar o que se han recibido
	
	
	rxWritePos++;
 150:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <rxWritePos>
 154:	02 c0       	rjmp	.+4      	; 0x15a <__vector_54+0x36>
	
	if(rxWritePos >= RX_BUFFER_SIZE)
	{
		rxWritePos = 0;
 156:	10 92 16 02 	sts	0x0216, r1	; 0x800216 <rxWritePos>
	}
}
 15a:	ff 91       	pop	r31
 15c:	ef 91       	pop	r30
 15e:	9f 91       	pop	r25
 160:	8f 91       	pop	r24
 162:	0f 90       	pop	r0
 164:	0b be       	out	0x3b, r0	; 59
 166:	0f 90       	pop	r0
 168:	0f be       	out	0x3f, r0	; 63
 16a:	0f 90       	pop	r0
 16c:	1f 90       	pop	r1
 16e:	18 95       	reti

00000170 <appendSerial>:

//////////////////////////////transmision////////////////////////////////////////////////////////////

void appendSerial(char c)
{
	serialBuffer[serialWritePos] = c;
 170:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <__data_end>
 174:	e9 2f       	mov	r30, r25
 176:	f0 e0       	ldi	r31, 0x00	; 0
 178:	e9 56       	subi	r30, 0x69	; 105
 17a:	fd 4f       	sbci	r31, 0xFD	; 253
 17c:	80 83       	st	Z, r24
	serialWritePos++;
 17e:	9f 5f       	subi	r25, 0xFF	; 255
	
	if(serialWritePos >= TX_BUFFER_SIZE)
 180:	1a f0       	brmi	.+6      	; 0x188 <appendSerial+0x18>
//////////////////////////////transmision////////////////////////////////////////////////////////////

void appendSerial(char c)
{
	serialBuffer[serialWritePos] = c;
	serialWritePos++;
 182:	90 93 14 02 	sts	0x0214, r25	; 0x800214 <__data_end>
 186:	08 95       	ret
	
	if(serialWritePos >= TX_BUFFER_SIZE)
	{
		serialWritePos = 0;
 188:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <__data_end>
 18c:	08 95       	ret

0000018e <serialWrite>:
	}
}

void serialWrite(char c[])
{
 18e:	1f 93       	push	r17
 190:	cf 93       	push	r28
 192:	df 93       	push	r29
 194:	ec 01       	movw	r28, r24
	for(uint8_t i = 0; i < strlen(c); i++)
 196:	10 e0       	ldi	r17, 0x00	; 0
 198:	06 c0       	rjmp	.+12     	; 0x1a6 <serialWrite+0x18>
	{
		appendSerial(c[i]);
 19a:	fe 01       	movw	r30, r28
 19c:	e2 0f       	add	r30, r18
 19e:	f3 1f       	adc	r31, r19
 1a0:	80 81       	ld	r24, Z
 1a2:	e6 df       	rcall	.-52     	; 0x170 <appendSerial>
	}
}

void serialWrite(char c[])
{
	for(uint8_t i = 0; i < strlen(c); i++)
 1a4:	1f 5f       	subi	r17, 0xFF	; 255
 1a6:	21 2f       	mov	r18, r17
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	fe 01       	movw	r30, r28
 1ac:	01 90       	ld	r0, Z+
 1ae:	00 20       	and	r0, r0
 1b0:	e9 f7       	brne	.-6      	; 0x1ac <serialWrite+0x1e>
 1b2:	31 97       	sbiw	r30, 0x01	; 1
 1b4:	ec 1b       	sub	r30, r28
 1b6:	fd 0b       	sbc	r31, r29
 1b8:	2e 17       	cp	r18, r30
 1ba:	3f 07       	cpc	r19, r31
 1bc:	70 f3       	brcs	.-36     	; 0x19a <serialWrite+0xc>
	{
		appendSerial(c[i]);
	}
	
	if(UCSR3A & (1 << UDRE3)) //verificar que el buffer de transmision este vacio
 1be:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
 1c2:	85 fd       	sbrc	r24, 5
	{
		UDR3 = 0;
 1c4:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
 1c8:	df 91       	pop	r29
 1ca:	cf 91       	pop	r28
 1cc:	1f 91       	pop	r17
 1ce:	08 95       	ret

000001d0 <main>:
void serialWrite(char  c[]);

int main(void)
{
	//guardar el valor de ubrr en los registros adecuados
	UBRR3H = (BRC >> 8);
 1d0:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
	UBRR3L =  BRC;
 1d4:	87 e6       	ldi	r24, 0x67	; 103
 1d6:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
	
	//habilitar recepcion (1 << RXEN3)  ,  habilitar flag de recepcion completa (1 << RXCIE3) ; transmision y  transmision completa
	UCSR3B = (1 << RXEN3)  | (1 << RXCIE3) | (1 << TXEN3)  | (1 << TXCIE3);
 1da:	88 ed       	ldi	r24, 0xD8	; 216
 1dc:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>

	//usart character size,  (1 << UCSZ31) | (1 << UCSZ30) para 8 bit ;
	//(0 <<UMSEL31) (0 <<UMSEL30) usart asincrona; (0 <<UPM31) |  (0 <<UPM30) sin paridad;    (0 <<USBS3) 1 bit de stop
	UCSR3C = (1 << UCSZ31) | (1 << UCSZ30) | (0 <<UMSEL31) | (0 <<UMSEL30) | (0 <<UPM31) |  (0 <<UPM30) | (0 <<USBS3) ;
 1e0:	86 e0       	ldi	r24, 0x06	; 6
 1e2:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>

	//poner el pin para rx como salida
	//DDRJ |= (1 << DDJ0);
	
	//habilitar interrupciones
	sei();
 1e6:	78 94       	sei

	serialWrite("\n\rHELLO\n\r");
 1e8:	80 e0       	ldi	r24, 0x00	; 0
 1ea:	92 e0       	ldi	r25, 0x02	; 2
 1ec:	d0 df       	rcall	.-96     	; 0x18e <serialWrite>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1ee:	2f ef       	ldi	r18, 0xFF	; 255
 1f0:	83 ed       	ldi	r24, 0xD3	; 211
 1f2:	90 e3       	ldi	r25, 0x30	; 48
 1f4:	21 50       	subi	r18, 0x01	; 1
 1f6:	80 40       	sbci	r24, 0x00	; 0
 1f8:	90 40       	sbci	r25, 0x00	; 0
 1fa:	e1 f7       	brne	.-8      	; 0x1f4 <main+0x24>
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <main+0x2e>
 1fe:	00 00       	nop
	_delay_ms(1000);
	while(1)
	{
		//enviar datos
		serialWrite("GOODByE\n\r");
 200:	8a e0       	ldi	r24, 0x0A	; 10
 202:	92 e0       	ldi	r25, 0x02	; 2
 204:	c4 df       	rcall	.-120    	; 0x18e <serialWrite>
 206:	2f ef       	ldi	r18, 0xFF	; 255
 208:	83 ed       	ldi	r24, 0xD3	; 211
 20a:	90 e3       	ldi	r25, 0x30	; 48
 20c:	21 50       	subi	r18, 0x01	; 1
 20e:	80 40       	sbci	r24, 0x00	; 0
 210:	90 40       	sbci	r25, 0x00	; 0
 212:	e1 f7       	brne	.-8      	; 0x20c <main+0x3c>
 214:	00 c0       	rjmp	.+0      	; 0x216 <main+0x46>
 216:	00 00       	nop
 218:	f3 cf       	rjmp	.-26     	; 0x200 <main+0x30>

0000021a <__vector_56>:
		UDR3 = 0;
	}
}

ISR(USART3_TX_vect)
{
 21a:	1f 92       	push	r1
 21c:	0f 92       	push	r0
 21e:	0f b6       	in	r0, 0x3f	; 63
 220:	0f 92       	push	r0
 222:	11 24       	eor	r1, r1
 224:	0b b6       	in	r0, 0x3b	; 59
 226:	0f 92       	push	r0
 228:	8f 93       	push	r24
 22a:	ef 93       	push	r30
 22c:	ff 93       	push	r31
	if(serialReadPos != serialWritePos)
 22e:	e0 91 15 02 	lds	r30, 0x0215	; 0x800215 <serialReadPos>
 232:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <__data_end>
 236:	e8 17       	cp	r30, r24
 238:	79 f0       	breq	.+30     	; 0x258 <__vector_56+0x3e>
	{
		UDR3 = serialBuffer[serialReadPos]; //no verifica si el buffer esta vacio porque esta funcion la llama la interrupcion de transmision completa
 23a:	f0 e0       	ldi	r31, 0x00	; 0
 23c:	e9 56       	subi	r30, 0x69	; 105
 23e:	fd 4f       	sbci	r31, 0xFD	; 253
 240:	80 81       	ld	r24, Z
 242:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
		serialReadPos++;
 246:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <serialReadPos>
 24a:	8f 5f       	subi	r24, 0xFF	; 255
		
		if(serialReadPos >= TX_BUFFER_SIZE)
 24c:	1a f0       	brmi	.+6      	; 0x254 <__vector_56+0x3a>
ISR(USART3_TX_vect)
{
	if(serialReadPos != serialWritePos)
	{
		UDR3 = serialBuffer[serialReadPos]; //no verifica si el buffer esta vacio porque esta funcion la llama la interrupcion de transmision completa
		serialReadPos++;
 24e:	80 93 15 02 	sts	0x0215, r24	; 0x800215 <serialReadPos>
 252:	02 c0       	rjmp	.+4      	; 0x258 <__vector_56+0x3e>
		
		if(serialReadPos >= TX_BUFFER_SIZE)
		{
			serialReadPos=0;
 254:	10 92 15 02 	sts	0x0215, r1	; 0x800215 <serialReadPos>
		}
	}
}
 258:	ff 91       	pop	r31
 25a:	ef 91       	pop	r30
 25c:	8f 91       	pop	r24
 25e:	0f 90       	pop	r0
 260:	0b be       	out	0x3b, r0	; 59
 262:	0f 90       	pop	r0
 264:	0f be       	out	0x3f, r0	; 63
 266:	0f 90       	pop	r0
 268:	1f 90       	pop	r1
 26a:	18 95       	reti

0000026c <_exit>:
 26c:	f8 94       	cli

0000026e <__stop_program>:
 26e:	ff cf       	rjmp	.-2      	; 0x26e <__stop_program>
